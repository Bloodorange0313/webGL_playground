<html>
  <head>
    <meta charset="utf-8" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/101/three.min.js"></script>
    <script>
      // ページの読み込みを待つ
      window.addEventListener('load', init);
      function init() {
        // サイズを指定
        const width = 1000;
        const height = 540;
        // レンダラーを作成
        const renderer = new THREE.WebGLRenderer({
          canvas: document.querySelector('#myCanvas'),
          antialias: true
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(width, height);
        // シーンを作成
        const scene = new THREE.Scene();
        // カメラを作成
        const camera = new THREE.PerspectiveCamera(45, width / height);
        camera.position.set(0, 0, +1000);
        // 円を作成
        const geometry = new THREE.CircleGeometry( 5, 32 );
        const material = new THREE.MeshBasicMaterial({ color: 0x6699ff });
        var NUM = 200;　// 生成するcubeの数
        var mesh = [];
        var v_x = [];
        var v_y = [];
        for(var i = 0; i < NUM; i++) {
          mesh[i] = new THREE.Mesh(geometry, material);
          var min = - height * 3 / 4;
          var max = height * 3 / 4;

          var a = Math.floor( Math.random() * (max + 1 - min) ) + min ;
          var b = Math.floor( Math.random() * (max + 1 - min) ) + min ;
          mesh[i].position.x = a;
          mesh[i].position.y = b;
          var MIN_VEL = 0.03;
          var MAX_VEL = 100.0;
          v_x[i] =  Math.random() * (MAX_VEL- MIN_VEL) + MIN_VEL;
          v_y[i] =  Math.random() * (MAX_VEL- MIN_VEL) + MIN_VEL;
          //console.log(v[i]);
          scene.add(mesh[i]);
        }
        
        tick();
        // 毎フレーム時に実行されるループイベントです

        


        function tick() {

          const COHESION_FORCE = 0.1
          const SEPARATION_FORCE = 0.1
          const ALIGNMENT_FORCE = 0.3
          const BOUNDARY_FORCE = 0.3

          const COHESION_DISTANCE = 100.0
          const SEPARATION_DISTANCE = 50.0
          const ALIGNMENT_DISTANCE = 200.0

          const COHESION_ANGLE = Math.PI / 2
          const SEPARATION_ANGLE = Math.PI / 2
          const ALIGNMENT_ANGLE = Math.PI / 3
          // メッシュを移動させる
          //distance = [];
          
          var distance = JSON.parse(JSON.stringify((new Array(NUM)).fill((new Array(NUM)).fill(100))));
          var radian = JSON.parse(JSON.stringify((new Array(NUM)).fill((new Array(NUM)).fill(0))));
          var degree = JSON.parse(JSON.stringify((new Array(NUM)).fill((new Array(NUM)).fill(0))));
          var coh_agents_x = [];
          var sep_agents_x = [];
          var ali_agents_x = [];
          var dv_coh_x = [];
          var dv_coh_y = [];
          var dv_sep_x = [];
          var dv_sep_y = [];
          var dv_ali_x = [];
          var dv_ali_y = [];
          var dv_boundary_x = [];
          var dv_boundary_y = [];
          var dist_center = [];
          
          //var coh_agents_x = JSON.parse(JSON.stringify((new Array(NUM)).fill((new Array(NUM)).fill())));
          for(var i = 0; i < NUM; i++) {
            


            var p_this = mesh[i].position;
              //console.log(p_this);
            var v_this_x = v_x[i];
            var v_this_y = v_y[i];
            
            
            for(var j = i + 1; j < NUM; j++){
              //mesh[i].position.x += v[i];
              

              var p_that = mesh[j].position;
              //console.log(p_that);
              var v_that_x = v_x[j];
              var v_that_y = v_y[j];

              distance[i][j] = Math.sqrt((p_that.x - p_this.x) * (p_that.x - p_this.x) + (p_that.y - p_this.y) * (p_that.y - p_this.y));
              //console.log(distance[i][j]);

              radian[i][j] = Math.atan2(p_that.y - p_this.y,p_that.x - p_this.x);
              degree[i][j] = radian[i][j] * 180/ Math.PI;
              //console.log(degree[i][j]);
              //各力が働く個体のリスト
              if((distance[i][j] < COHESION_DISTANCE) && (degree[i][j] < COHESION_ANGLE)){
                coh_agents_x.push(j);
                //console.log(coh_agents_x);
              }
              if((distance[i][j] < SEPARATION_DISTANCE) && (degree[i][j] < SEPARATION_ANGLE)){
                sep_agents_x.push(j);
              }
              if((distance[i][j] < ALIGNMENT_DISTANCE) && (degree[i][j] < ALIGNMENT_ANGLE)){
                ali_agents_x.push(j);
              }
              

            }
            var x_sum_coh = 0;
              var y_sum_coh = 0;
              for(var k = 0; k < coh_agents_x.length; ++k){
                x_sum_coh += mesh[coh_agents_x[k]].position.x;
                y_sum_coh += mesh[coh_agents_x[k]].position.y;
                //console.log(mesh[coh_agents_x[k]].position.x);
              }

              var x_sum_sep = 0;
              var y_sum_sep = 0;
              for(var k = 0; k < sep_agents_x.length; ++k){
                x_sum_sep += p_this.y - mesh[sep_agents_x[k]].position.x;
                y_sum_sep += p_this.y - mesh[sep_agents_x[k]].position.y;
                //console.log(mesh[coh_agents_x[k]].position.x);
              }
              //console.log(x_sum_sep);

              var x_sum_ali = 0;
              var y_sum_ali = 0;
              for(var k = 0; k < ali_agents_x.length; ++k){
                x_sum_ali += mesh[ali_agents_x[k]].position.x;
                y_sum_ali += mesh[ali_agents_x[k]].position.y;
                //console.log(mesh[coh_agents_x[k]].position.x);
              }
              //console.log(x_sum_coh);
              
              if(coh_agents_x.length > 0){
                dv_coh_x[i] = COHESION_FORCE * ((x_sum_coh / coh_agents_x.length) - p_this.x);
                dv_coh_y[i] = COHESION_FORCE * ((y_sum_coh / coh_agents_x.length) - p_this.y);
              }else{
                dv_coh_x[i] = 0.0;
                dv_coh_y[i] = 0.0;
              }
              if(sep_agents_x.length > 0){
                dv_sep_x[i] = SEPARATION_FORCE * x_sum_sep;
                dv_sep_y[i] = SEPARATION_FORCE * y_sum_sep;
              }else{
                dv_sep_x[i] = 0.0;
                dv_sep_y[i] = 0.0;
              }
              //console.log(dv_sep_x);
              if(ali_agents_x.length > 0){
                dv_ali_x[i] = ALIGNMENT_FORCE * ((x_sum_ali / ali_agents_x.length) - v_this_x);
                dv_ali_y[i] = ALIGNMENT_FORCE * ((y_sum_ali / ali_agents_x.length) - v_this_y);
              }else{
                dv_ali_x[i] = 0.0;
                dv_ali_y[i] = 0.0;
              }

              dist_center[i] = Math.sqrt((p_this.x - 0.0) * (p_this.x - 0.0) + (p_this.y - 0.0) * (p_this.y - 0.0) );
              //console.log(dist_center[i]);
              if(dist_center > 1){
                dv_boundary_x[i] = - BOUNDARY_FORCE * p_this.x * (dist_center - 1) / dist_center;
                dv_boundary_y[i] = - BOUNDARY_FORCE * p_this.y * (dist_center - 1) / dist_center;
              }else{
                dv_boundary_x[i] = 0.0;
                dv_boundary_y[i] = 0.0;
              }
              
              //console.log(dv_boundary_x);
              //console.log(dv_coh_x[i] + dv_sep_x[i] + dv_ali_x[i] + dv_boundary_x[i]);
              
              v_x[i] += dv_coh_x[i] + dv_sep_x[i] + dv_ali_x[i] + dv_boundary_x[i];
              v_y[i] += dv_coh_y[i] + dv_sep_y[i] + dv_ali_y[i] + dv_boundary_y[i];
              /*
              if(Math.abs(v_x[i])  > MAX_VEL){
                v_x[i] *= 0.6;
              }
              if(Math.abs(v_y[i])  > MAX_VEL){
                v_y[i] *= 0.6;
              }
              if(Math.abs(v_x[i]) < MIN_VEL){
                v_x[i] *= 1.3;
              }
              if(Math.abs(v_y[i]) < MIN_VEL){
                v_y[i] *= 1.3;
              }
              */
              /*
              
              if(Math.abs(p_this.x) > width / 2 - 5 ){
                v_x[i] *= -1.5;
              }
              
              if(Math.abs(p_this.y) > height /2 - 10 ){
                  v_y[i] *= -1.5;
              }
              */
              /*
              if(Math.abs(v_x[i]) > MAX_VEL / 100.0){
                v_x[i] *= 0.8;
              }
              if(Math.abs(v_y[i]) > MAX_VEL / 100.0){
                v_y[i] *= 0.8;
              }
              */
              
              p_this.x += v_x[i] / 1000.0;
              p_this.y += v_y[i] / 1000.0;
              
              
              console.log(v_x[i]);

            
            
            //
            //if(Math.abs(Math.min.apply(null, distance[i])) > 10){
              ///mesh[i].position.x += v_this;
              //mesh[i].position.y += v_this;
            //}
            //console.log(Math.min.apply(null, distance[i]));

          }
          
          // レンダリング
          renderer.render(scene, camera);
          requestAnimationFrame(tick);
        }
      }
    </script>
  </head>
  <body>
    <canvas id="myCanvas"></canvas>
  </body>
</html>
